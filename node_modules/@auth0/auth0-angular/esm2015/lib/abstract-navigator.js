import { Injectable, Injector } from '@angular/core';
import { Router } from '@angular/router';
import { Location } from '@angular/common';
import * as i0 from "@angular/core";
import * as i1 from "@angular/common";
import * as ɵngcc0 from '@angular/core';
import * as ɵngcc1 from '@angular/common';
export class AbstractNavigator {
    constructor(location, injector) {
        this.location = location;
        try {
            this.router = injector.get(Router);
        }
        catch (_a) { }
    }
    /**
     * Navigates to the specified url. The router will be used if one is available, otherwise it falls back
     * to `window.history.replaceState`.
     * @param url The url to navigate to
     */
    navigateByUrl(url) {
        if (this.router) {
            this.router.navigateByUrl(url);
            return;
        }
        this.location.replaceState(url);
    }
}
AbstractNavigator.ɵfac = function AbstractNavigator_Factory(t) { return new (t || AbstractNavigator)(ɵngcc0.ɵɵinject(ɵngcc1.Location), ɵngcc0.ɵɵinject(ɵngcc0.Injector)); };
AbstractNavigator.ɵprov = i0.ɵɵdefineInjectable({ factory: function AbstractNavigator_Factory() { return new AbstractNavigator(i0.ɵɵinject(i1.Location), i0.ɵɵinject(i0.INJECTOR)); }, token: AbstractNavigator, providedIn: "root" });
AbstractNavigator.ctorParameters = () => [
    { type: Location },
    { type: Injector }
];
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(AbstractNavigator, [{
        type: Injectable,
        args: [{
                providedIn: 'root'
            }]
    }], function () { return [{ type: ɵngcc1.Location }, { type: ɵngcc0.Injector }]; }, null); })();

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYWJzdHJhY3QtbmF2aWdhdG9yLmpzIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi8uLi8uLi8uLi9mcmVkZXJpa3ByaWpjay9EZXZlbG9wbWVudC9hdXRoMC1hbmd1bGFyL3Byb2plY3RzL2F1dGgwLWFuZ3VsYXIvc3JjL2xpYi9hYnN0cmFjdC1uYXZpZ2F0b3IudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFFLFVBQVUsRUFBRSxRQUFRLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFDckQsT0FBTyxFQUFFLE1BQU0sRUFBRSxNQUFNLGlCQUFpQixDQUFDO0FBQ3pDLE9BQU8sRUFBRSxRQUFRLEVBQUUsTUFBTSxpQkFBaUIsQ0FBQztBQUMzQztBQUdBOzs7QUFDQSxNQUFNLE9BQU8saUJBQWlCO0FBQzlCLElBRUUsWUFBb0IsUUFBa0IsRUFBRSxRQUFrQjtBQUM1RCxRQURzQixhQUFRLEdBQVIsUUFBUSxDQUFVO0FBQUMsUUFDckMsSUFBSTtBQUNSLFlBQU0sSUFBSSxDQUFDLE1BQU0sR0FBRyxRQUFRLENBQUMsR0FBRyxDQUFDLE1BQU0sQ0FBQyxDQUFDO0FBQ3pDLFNBQUs7QUFBQyxRQUFBLFdBQU0sR0FBRTtBQUNkLElBQUUsQ0FBQztBQUNILElBQ0U7QUFDRjtBQUNFO0FBQ0U7QUFFSixPQURLO0FBQ0wsSUFBRSxhQUFhLENBQUMsR0FBVztBQUFJLFFBQzNCLElBQUksSUFBSSxDQUFDLE1BQU0sRUFBRTtBQUNyQixZQUFNLElBQUksQ0FBQyxNQUFNLENBQUMsYUFBYSxDQUFDLEdBQUcsQ0FBQyxDQUFDO0FBQ3JDLFlBQ00sT0FBTztBQUNiLFNBQUs7QUFDTCxRQUNJLElBQUksQ0FBQyxRQUFRLENBQUMsWUFBWSxDQUFDLEdBQUcsQ0FBQyxDQUFDO0FBQ3BDLElBQUUsQ0FBQztBQUNIOzRLQUFDO0FBQ0QsdU9BeEJLO0FBQUM7RUFITCxVQUFVLFNBQUMsckJBSUksWUFOUCxRQUFRO2VBR2YsZkFIbUIsWUFGQSxRQUFRO0VBS2pCLEZBTG9CO0NBS2xCLE1BQU0sZUFDbkI7Ozs7O29HQU5pQztBQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgSW5qZWN0YWJsZSwgSW5qZWN0b3IgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IFJvdXRlciB9IGZyb20gJ0Bhbmd1bGFyL3JvdXRlcic7XG5pbXBvcnQgeyBMb2NhdGlvbiB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5cbkBJbmplY3RhYmxlKHtcbiAgcHJvdmlkZWRJbjogJ3Jvb3QnLFxufSlcbmV4cG9ydCBjbGFzcyBBYnN0cmFjdE5hdmlnYXRvciB7XG4gIHByaXZhdGUgcmVhZG9ubHkgcm91dGVyOiBSb3V0ZXI7XG5cbiAgY29uc3RydWN0b3IocHJpdmF0ZSBsb2NhdGlvbjogTG9jYXRpb24sIGluamVjdG9yOiBJbmplY3Rvcikge1xuICAgIHRyeSB7XG4gICAgICB0aGlzLnJvdXRlciA9IGluamVjdG9yLmdldChSb3V0ZXIpO1xuICAgIH0gY2F0Y2gge31cbiAgfVxuXG4gIC8qKlxuICAgKiBOYXZpZ2F0ZXMgdG8gdGhlIHNwZWNpZmllZCB1cmwuIFRoZSByb3V0ZXIgd2lsbCBiZSB1c2VkIGlmIG9uZSBpcyBhdmFpbGFibGUsIG90aGVyd2lzZSBpdCBmYWxscyBiYWNrXG4gICAqIHRvIGB3aW5kb3cuaGlzdG9yeS5yZXBsYWNlU3RhdGVgLlxuICAgKiBAcGFyYW0gdXJsIFRoZSB1cmwgdG8gbmF2aWdhdGUgdG9cbiAgICovXG4gIG5hdmlnYXRlQnlVcmwodXJsOiBzdHJpbmcpOiB2b2lkIHtcbiAgICBpZiAodGhpcy5yb3V0ZXIpIHtcbiAgICAgIHRoaXMucm91dGVyLm5hdmlnYXRlQnlVcmwodXJsKTtcblxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMubG9jYXRpb24ucmVwbGFjZVN0YXRlKHVybCk7XG4gIH1cbn1cbiJdfQ==